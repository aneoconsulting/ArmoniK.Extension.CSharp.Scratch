// This file is part of the ArmoniK project
// 
// Copyright (C) ANEO, 2021-2025. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Threading;

using ArmoniK.Api.gRPC.V1.Results;
using ArmoniK.Extension.CSharp.Client.Common.Domain.Blob;
using ArmoniK.Extension.CSharp.Client.Common.Enum;
using ArmoniK.Extension.CSharp.Client.Common.Services;

using Microsoft.Extensions.Logging;

namespace ArmoniK.Extension.CSharp.Client.Filtering;

/// <summary>
///   Class query provider that build the protobuf filtering structure
/// </summary>
public class BlobQueryProvider : IAsyncQueryProvider<BlobState>
{
  private readonly IBlobService          blobService_;
  private readonly ILogger<IBlobService> logger_;

  /// <summary>
  ///   Create the query provider
  /// </summary>
  /// <param name="blobService">The Blob service</param>
  /// <param name="logger">The logger</param>
  public BlobQueryProvider(IBlobService          blobService,
                           ILogger<IBlobService> logger)
  {
    blobService_ = blobService;
    logger_      = logger;
  }

  /// <summary>
  ///   The pagination properties generated by the latest filter execution
  /// </summary>
  public BlobPagination BlobPagination { get; private set; }

  /// <summary>
  ///   Create the query object
  /// </summary>
  /// <param name="expression">The filtering expression</param>
  /// <returns>The query object</returns>
  public IQueryable CreateQuery(Expression expression)
    => new ArmoniKQueryable<BlobState>(this,
                                       expression);

  /// <summary>
  ///   Create the query object
  /// </summary>
  /// <param name="expression">The filtering expression</param>
  /// <returns>The query object</returns>
  public IQueryable<TElement> CreateQuery<TElement>(Expression expression)
    => new ArmoniKQueryable<TElement>(this,
                                      expression);

  /// <summary>
  ///   VisitTree the expression tree and generate the protobuf filtering structures
  ///   and fetches the BlobState instances according to the filter.
  /// </summary>
  /// <param name="expression">The filtering expression</param>
  /// <returns>An enumeration of BlobState instances compliant with the filter</returns>
  /// <exception cref="InvalidExpressionException">When the filtering expression is invalid</exception>
  public object Execute(Expression expression)
    => ExecuteAsync(expression)
       .ToListAsync()
       .Result;


  /// <summary>
  ///   VisitTree the expression tree and generate the protobuf filtering structures
  ///   and fetches the BlobState instances according to the filter.
  /// </summary>
  /// <param name="expression">The filtering expression</param>
  /// <returns>An enumeration of BlobState instances compliant with the filter</returns>
  /// <exception cref="InvalidExpressionException">When the filtering expression is invalid</exception>
  public TResult Execute<TResult>(Expression expression)
    => (TResult)Execute(expression);

  /// <summary>
  ///   VisitTree the expression tree and generate the protobuf filtering structures
  ///   and fetches the BlobState instances according to the filter.
  /// </summary>
  /// <param name="expression">The filtering expression</param>
  /// <param name="cancellationToken">The cancellation token</param>
  /// <returns>An asynchronous enumeration of BlobState instances compliant with the filter</returns>
  /// <exception cref="InvalidExpressionException">When the filtering expression is invalid</exception>
  public async IAsyncEnumerable<BlobState> ExecuteAsync(Expression                                 expression,
                                                        [EnumeratorCancellation] CancellationToken cancellationToken = default)
  {
    var visitor = new BlobFilterExpressionTreeVisitor(expression);

    try
    {
      visitor.VisitTree();
    }
    catch (Exception ex)
    {
      logger_.LogError(ex,
                       "Invalid blob filter: " + expression);
      throw new InvalidExpressionException("Invalid blob filter: " + expression,
                                           ex);
    }

    BlobPagination = new BlobPagination
                     {
                       Filter        = visitor.Filters ?? new Filters(),
                       Page          = -1,
                       PageSize      = 50,
                       SortDirection = SortDirection.Asc,
                       SortField = new ResultField
                                   {
                                     ResultRawField = new ResultRawField
                                                      {
                                                        Field = ResultRawEnumField.ResultId,
                                                      },
                                   },
                     };
    var      total = 0;
    BlobPage page;
    do
    {
      BlobPagination.Page++;
      page = await blobService_.ListBlobsAsync(BlobPagination,
                                               cancellationToken)
                               .ConfigureAwait(false);
      total += page.Blobs.Length;
      foreach (var blobState in page.Blobs)
      {
        yield return blobState;
      }
    } while (total < page.TotalBlobCount);
  }
}
