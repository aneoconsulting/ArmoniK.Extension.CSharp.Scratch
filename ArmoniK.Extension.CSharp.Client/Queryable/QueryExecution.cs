// This file is part of the ArmoniK project
// 
// Copyright (C) ANEO, 2021-2025. All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License")
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

using System;
using System.Collections.Generic;
using System.Data;
using System.Linq.Expressions;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace ArmoniK.Extension.CSharp.Client.Queryable;

/// <summary>
///   Class in charge of the execution of a query built with an IQueryable
/// </summary>
/// <typeparam name="TPagination">The type of the protobuf instance that contains all the information of a request.</typeparam>
/// <typeparam name="TPage">The type of page of elements returned by the query.</typeparam>
/// <typeparam name="TSource">The type of the requested instances.</typeparam>
/// <typeparam name="TSortField">The type of the protobuf instance that describe how to sort the results.</typeparam>
/// <typeparam name="TFilterOr">The type of the protobuf instance that represents a logical OR node.</typeparam>
/// <typeparam name="TFilterAnd">The type of the protobuf instance that represents a logical AND node.</typeparam>
/// <typeparam name="TFilterField">The type of the protobuf instance that describe a filter on a single property.</typeparam>
internal abstract class QueryExecution<TPagination, TPage, TSource, TSortField, TFilterOr, TFilterAnd, TFilterField>
  where TFilterOr : new()
  where TFilterAnd : new()
{
  private QueryExpressionTreeVisitor<TSource, TSortField, TFilterOr, TFilterAnd, TFilterField> visitor_;

  /// <summary>
  ///   Not null when an extension method retuning TSource? has been applied
  ///   on the IQueryable instance.
  /// </summary>
  public Func<IAsyncEnumerable<TSource>, TSource?>? FuncReturnNullableTSource
    => visitor_.FuncReturnNullableTSource;

  /// <summary>
  ///   Not null when an extension method retuning TSource has been applied
  ///   on the IQueryable instance.
  /// </summary>
  public Func<IAsyncEnumerable<TSource>, TSource>? FuncReturnTSource
    => visitor_.FuncReturnTSource;

  /// <summary>
  ///   The pagination properties generated by the latest query execution
  /// </summary>
  public TPagination PaginationInstance { get; private set; }

  /// <summary>
  ///   Visit the entire Expression Tree of a query
  /// </summary>
  /// <param name="expression">The Expression Tree</param>
  /// <exception cref="InvalidExpressionException">When the query is invalid.</exception>
  public void VisitExpression(Expression expression)
  {
    try
    {
      visitor_ = CreateQueryExpressionTreeVisitor();
      visitor_.VisitTree(expression);
    }
    catch (Exception ex)
    {
      LogError(ex,
               "Invalid query: " + expression);
      throw new InvalidExpressionException("Invalid query: " + expression,
                                           ex);
    }
  }

  /// <summary>
  ///   Execute the query asynchronously by seamlessly fetching several pages of results.
  /// </summary>
  /// <param name="cancellationToken">The cancellation token</param>
  /// <returns>An asynchronous enumerable of the results.</returns>
  /// <exception cref="InvalidOperationException">When the Expression Tree has not been visited beforehand.</exception>
  public async IAsyncEnumerable<TSource> ExecuteAsync([EnumeratorCancellation] CancellationToken cancellationToken = default)
  {
    if (visitor_ == null)
    {
      throw new InvalidOperationException("VisitExpression() must be called before ExecuteAsync()");
    }

    PaginationInstance = CreatePaginationInstance(visitor_.Filters,
                                                  visitor_.SortCriteria,
                                                  visitor_.IsSortAscending);
    var   total = 0;
    TPage page;
    do
    {
      page = await RequestInstances(PaginationInstance,
                                    cancellationToken)
               .ConfigureAwait(false);
      var elements = GetPageElements(page);
      foreach (var blobState in elements)
      {
        total++;
        yield return blobState;
      }
    } while (total < GetTotalPageElements(page));
  }

  protected abstract void LogError(Exception ex,
                                   string    message);

  protected abstract Task<TPage> RequestInstances(TPagination       pagination,
                                                  CancellationToken cancellationToken);

  protected abstract QueryExpressionTreeVisitor<TSource, TSortField, TFilterOr, TFilterAnd, TFilterField> CreateQueryExpressionTreeVisitor();

  protected abstract TPagination CreatePaginationInstance(TFilterOr  filter,
                                                          TSortField sortCriteria,
                                                          bool       isAscending);

  protected abstract int                  GetTotalPageElements(TPage page);
  protected abstract IEnumerable<TSource> GetPageElements(TPage      page);
}
